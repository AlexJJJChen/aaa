# -*- coding: utf-8 -*-
"""
Document Formatter with AI-Powered Title Hierarchy Analysis

This script takes the output from the table extraction pipeline (`_combined_document.json`),
uses a Large Language Model (LLM) to analyze and assign hierarchical levels to titles,
and then generates both a final structured JSON and a clean Markdown document.

This is the final step to convert raw OCR data into a usable, structured document.

Required libraries:
pip install openai tqdm
"""
import json
import os
from openai import OpenAI
from tqdm import tqdm
import time
import re

# --- ‚öôÔ∏è Configuration ---
class Config:
    # 1. ËæìÂÖ•Êñá‰ª∂Ôºö‰∏ä‰∏Ä‰∏™ÊµÅÁ®ãÁîüÊàêÁöÑËÅöÂêàJSONÊñá‰ª∂ÁöÑË∑ØÂæÑ
    # The path to the combined JSON file generated by the previous pipeline.
    INPUT_JSON_PATH = "/project/chenjian/aaa/output_[ÂÆöÊúüÊä•Âëä][2023-03-20][ÊúóÈ∏øÁßëÊäÄ]ÊúóÈ∏øÁßëÊäÄ2022Âπ¥Âπ¥Â∫¶Êä•ÂëäÊëòË¶Å/_combined_document.json"

    # 2. ËæìÂá∫Êñá‰ª∂ÔºöÂÆö‰πâÊúÄÁªà‰∫ßÂá∫Êñá‰ª∂ÁöÑÂêçÁß∞
    # Define the names for the final output files.
    FINAL_JSON_WITH_HIERARCHY = "_document_with_hierarchy.json"
    FINAL_MARKDOWN_FILENAME = "_final_document.md"
    
    # 3. AIÊ®°ÂûãÈÖçÁΩÆ (Custom OpenAI-compatible API)
    # Configuration for your specific OpenAI-compatible API endpoint.
    API_KEY = "sk-3ni5O4wR7GTeeqKvFdC5D12f280b460797E7369455283a7d"
    API_BASE_URL = "http://152.53.52.170:3003/v1"
    MODEL_NAME = "gpt-4.1-mini-2025-04-14"

# ======================================================================================
# --- STAGE 1: Load and Prepare Data ---
# ======================================================================================
def load_document(file_path):
    """Loads the combined document JSON from the specified path."""
    print(f"üìÑ Loading document from: {file_path}")
    if not os.path.exists(file_path):
        print(f"‚ùå ERROR: Input file not found at '{file_path}'. Please check the path.")
        return None
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        print("‚úÖ Document loaded successfully.")
        return data
    except Exception as e:
        print(f"‚ùå ERROR: Failed to load or parse JSON file. Details: {e}")
        return None

# ======================================================================================
# --- STAGE 2: AI-Powered Title Hierarchy Analysis ---
# ======================================================================================
def analyze_title_hierarchy_with_ai(titles_toc):
    """
    Sends the list of titles to a custom API to determine their hierarchical level.
    
    Args:
        titles_toc (list): The table of contents list from the input JSON.

    Returns:
        list: A list of dicts with the analyzed hierarchy, or None on failure.
    """
    print("\n" + "="*80)
    print("--- STAGE 2: Analyzing Title Hierarchy with AI ---")
    print(f"üß† Sending {len(titles_toc)} titles to the AI at {Config.API_BASE_URL} for analysis...")
    
    # Prepare the list of title strings for the prompt
    title_texts = [item['title_content'] for item in titles_toc]
    
    # Construct a detailed prompt with instructions for the AI
    prompt_content = f"""
    You are an expert in document structure analysis.
    Below is a list of sequential titles extracted from a document.
    Your task is to analyze this list and determine the hierarchical level of each title.
    
    - The top-level main titles should be level 1.
    - Sub-titles under a level 1 title should be level 2.
    - Sub-sub-titles under a level 2 title should be level 3, and so on.
    - Some items might not be real titles (e.g., '‚ñ°ÈÄÇÁî®‚àö‰∏çÈÄÇÁî®', notes, or stray text). For these, assign level 0.
    
    Here is the list of titles:
    {json.dumps(title_texts, ensure_ascii=False, indent=2)}
    
    Please return your analysis strictly as a JSON array of objects, where each object contains the key "original_title" and "hierarchical_level". Do not include any other text, markdown formatting, or explanations in your response.
    """

    # Initialize the OpenAI client with your custom endpoint
    try:
        client = OpenAI(api_key=Config.API_KEY, base_url=Config.API_BASE_URL)

        completion = client.chat.completions.create(
            model=Config.MODEL_NAME,
            messages=[
                {"role": "system", "content": "You are an AI assistant that analyzes document structures and returns ONLY valid JSON."},
                {"role": "user", "content": prompt_content}
            ],
            temperature=0.0,
        )
        
        response_content = completion.choices[0].message.content
        
        # The model might wrap the JSON in markdown, so we extract it.
        json_match = re.search(r'```json\n(.*?)\n```', response_content, re.DOTALL)
        if json_match:
            json_string = json_match.group(1).strip()
        else:
            json_string = response_content.strip()

        analysis_result = json.loads(json_string)
        print("‚úÖ AI analysis complete.")
        return analysis_result

    except Exception as e:
        print(f"‚ùå ERROR: An exception occurred during the API call: {e}")
        return None

# ======================================================================================
# --- STAGE 3: Integrate Hierarchy and Generate Final Document ---
# ======================================================================================
def integrate_hierarchy_and_generate_markdown(document_data, hierarchy_analysis):
    """
    Integrates the AI's hierarchy analysis back into the document and generates a Markdown file.
    
    Args:
        document_data (dict): The original, loaded document data.
        hierarchy_analysis (list): The list of analyzed titles from the AI.

    Returns:
        dict: The final document data with integrated hierarchy information.
    """
    print("\n" + "="*80)
    print("--- STAGE 3: Integrating Hierarchy and Generating Markdown ---")

    # Create a mapping from title content to its hierarchical level for easy lookup
    title_to_level_map = {item['original_title']: item['hierarchical_level'] for item in hierarchy_analysis}

    # Iterate through the document content and add the 'hierarchical_level'
    for page in document_data['document_content']:
        for block in page['parsing_res_list']:
            if 'title' in block.get('block_label', ''):
                level = title_to_level_map.get(block['block_content'], 0) # Default to 0 if not found
                block['hierarchical_level'] = level
    
    print("‚úÖ Hierarchy information integrated into the final JSON structure.")
    return document_data

def generate_markdown_from_structured_json(structured_data):
    """Converts the final structured JSON into a Markdown string."""
    markdown_lines = []
    
    for page in tqdm(structured_data['document_content'], desc="Generating Markdown"):
        for block in page['parsing_res_list']:
            label = block.get('block_label', 'text')
            content = block.get('block_content', '')
            
            if 'title' in label:
                level = block.get('hierarchical_level', 0)
                if level > 0:
                    markdown_lines.append(f"{'#' * level} {content}\n")
                else:
                    # Treat items classified as "not a title" as regular text
                    markdown_lines.append(f"{content}\n")
            elif label == 'table':
                # Add a newline before and after tables for better spacing
                markdown_lines.append(f"\n{content}\n")
            else: # Handle 'text', 'footer', 'header', etc. as plain paragraphs
                markdown_lines.append(f"{content}\n")

    print("‚úÖ Markdown content generated.")
    return "\n".join(markdown_lines)

# ======================================================================================
#  --- Main Execution Orchestrator ---
# ======================================================================================
def main():
    """Main function to orchestrate the entire document formatting pipeline."""
    pipeline_start_time = time.time()
    
    # Stage 1: Load the document
    doc_data = load_document(Config.INPUT_JSON_PATH)
    if not doc_data:
        return
        
    # Stage 2: Get hierarchy from AI
    hierarchy = analyze_title_hierarchy_with_ai(doc_data.get('titles_toc', []))
    if not hierarchy:
        print("Pipeline stopped due to error in AI analysis stage.")
        return
        
    # Stage 3: Integrate results
    final_data = integrate_hierarchy_and_generate_markdown(doc_data, hierarchy)
    
    # Generate final Markdown content
    final_markdown = generate_markdown_from_structured_json(final_data)

    # Save the final files
    output_dir = os.path.dirname(Config.INPUT_JSON_PATH)
    final_json_path = os.path.join(output_dir, Config.FINAL_JSON_WITH_HIERARCHY)
    final_md_path = os.path.join(output_dir, Config.FINAL_MARKDOWN_FILENAME)

    try:
        with open(final_json_path, 'w', encoding='utf-8') as f:
            json.dump(final_data, f, ensure_ascii=False, indent=4)
        print(f"\nüíæ Final structured JSON saved to: {final_json_path}")
        
        with open(final_md_path, 'w', encoding='utf-8') as f:
            f.write(final_markdown)
        print(f"üíæ Final Markdown document saved to: {final_md_path}")
        
    except Exception as e:
        print(f"‚ùå ERROR: Failed to save output files. Details: {e}")

    # --- Final Summary ---
    pipeline_elapsed_time = time.time() - pipeline_start_time
    print("\n" + "#"*80)
    print("üéâ DOCUMENT FORMATTING COMPLETE! üéâ")
    print(f"Total execution time: {pipeline_elapsed_time:.2f} seconds")
    print("#"*80)

if __name__ == "__main__":
    main()
